<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aviator Smart Signals V10 - Estilizado</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <style>
        :root{
            --bg:#0b0f18;
            --panel:rgba(15, 21, 36, 0.6); 
            --panel-2:rgba(13, 19, 32, 0.7);
            --stroke:rgba(30, 42, 71, 0.5); 
            --text:#e6e8ee; /* Texto padrão branco/claro */
            --muted:#a8b0c3;
            --success:#22c55e; /* WIN (Verde) */
            --danger:#ef4444; /* LOSS (Vermelho) */
            --warn:#f59e0b; /* Amarelo (Não usado para INFO) */
            --card-radius:18px; 
            --shadow:0 10px 30px rgba(0,0,0,.35);
            
            /* Cores Neon e Histórico */
            --blue-neon: #2563eb; /* INFO (Azul) */
            --purple-neon: #7c3aed;
            --pink-neon: #ec4899;

            --hist-blue-bg: rgba(37, 99, 235, 0.15);
            --hist-purple-bg: rgba(124, 58, 237, 0.2);
            --hist-pink-bg: rgba(236, 72, 153, 0.25);
        }
        
        body{
            background: radial-gradient(1200px 800px at 10% -10%, #141b2f 0%, transparent 60%),
                        radial-gradient(800px 600px at 90% 10%, #1a1f36 0%, transparent 60%),
                        var(--bg);
            color: var(--text);
            font-family: 'Inter', sans-serif;
            padding-bottom: 20px;
        }

        .container-fluid {
            max-width: 600px;
        }
        
        /* Cards Básicos (transparente) */
        .card {
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border: 1px solid var(--stroke);
            border-radius: var(--card-radius);
            box-shadow: var(--shadow);
            padding: 16px;
            backdrop-filter: blur(4px);
        }

        /* CARD DE SINAL CENTRAL (Ajustado para ser menor) */
        .chance-card {
            position: relative;
            border-radius: var(--card-radius); 
            background: rgba(37, 99, 235, 0.15); 
            border: 1px solid rgba(37, 99, 235, 0.3);
            backdrop-filter: blur(6px);
            transition: all 0.25s ease;
            overflow: hidden; 
            padding: 16px; /* Reduzido de 20px */
        }

        /* TÍTULO PRINCIPAL DO SINAL - MAIOR E MAIS CHAMATIVO (Reduzido) */
        .chance-title {
            font-size: 1.8rem; /* Reduzido de 2.2rem */
            font-weight: 900; 
            margin-bottom: 5px;
            color: var(--text);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.4), 0 0 10px rgba(124, 58, 237, 0.5); 
        }
        
        .chance-sub {
            font-size: 0.85rem; /* Reduzido de 0.95rem */
            color: var(--muted);
            margin-bottom: 12px;
        }

        .sep {
            height: 1px;
            background-color: var(--stroke);
            margin: 15px 0;
        }
        
        /* Keyframes para as linhas giratórias */
        @keyframes spin-lines {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Status: SINAL ATIVO (G0, G1, G2) -> ROXO + ANIMAÇÃO DE LINHAS */
        .chance-card.chance-active {
            position: relative; 
            background: rgba(124, 58, 237, 0.2);
            border: 1px solid transparent; 
            box-shadow: none;
            z-index: 1; 
        }
        
        /* Linhas giratórias mantidas */
        .chance-card.chance-active::before {
            content: '';
            position: absolute;
            top: -2px; bottom: -2px; left: -2px; right: -2px;
            border-radius: var(--card-radius);
            z-index: -1;
            pointer-events: none;
            border: 3px solid transparent;
            border-top-color: var(--purple-neon);
            border-bottom-color: var(--purple-neon);
            animation: spin-lines 4s linear infinite;
        }

        .chance-card.chance-active::after {
            content: '';
            position: absolute;
            top: -2px; bottom: -2px; left: -2px; right: -2px;
            border-radius: var(--card-radius);
            z-index: -1;
            pointer-events: none;
            border: 3px solid transparent;
            border-left-color: var(--purple-neon);
            border-right-color: var(--purple-neon);
            animation: spin-lines 6s linear infinite reverse; 
        }

        /* Status: AGUARDANDO PADRÃO -> AMARELO */
        .chance-card.chance-awaiting {
            background: rgba(245, 158, 11, 0.15); 
            border: 1px dashed rgba(245, 158, 11, 0.6);
            box-shadow: none;
        }
        
        /* Efeito de Flash */
        .chance-animate {
            transform: scale(1.02);
            box-shadow: 0 0 20px 4px var(--purple-neon) !important;
        }
        /* Status: BLOQUEADO (Vermelho do botscript) */
        .chance-card.chance-blocked {
            background: rgba(239, 44, 44, 0.1); 
            border: 1px solid rgba(239, 44, 44, 0.4);
        }

        /* Estilo dos Cards de Estratégia/Gatilho (Preto Arredondado) */
        .pill {
            background: rgba(0, 0, 0, 0.4); 
            border: 1px solid rgba(255, 255, 255, 0.05); 
            color: var(--muted);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        /* ÍCONES SIMPLES */
        .btn-simple-icon {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text);
            border: 1px solid var(--stroke);
            font-size: 1.2rem;
            padding: 6px 12px;
            min-width: 45px;
            border-radius: 8px;
            text-align: center;
            text-decoration: none;
            transition: background 0.2s;
            font-family: sans-serif; 
        }

        /* Cards de Análise (Mantidos) */
        .output-cards-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .analise-card {
            background: rgba(15, 21, 36, 0.4); 
            padding: 12px 8px;
            border-radius: 12px;
            border: 1px solid transparent;
            box-shadow: 0 0 10px rgba(0,0,0,.5);
        }
        .analise-card.neon-blue { border: 1px solid var(--blue-neon); box-shadow: 0 0 12px rgba(37, 99, 235, 0.5), inset 0 0 6px rgba(37, 99, 235, 0.3); }
        .analise-card.neon-purple { border: 1px solid var(--purple-neon); box-shadow: 0 0 12px rgba(124, 58, 237, 0.5), inset 0 0 6px rgba(124, 58, 237, 0.3); }
        .analise-card.neon-pink { border: 1px solid var(--pink-neon); box-shadow: 0 0 12px rgba(236, 72, 153, 0.5), inset 0 0 6px rgba(236, 72, 153, 0.3); }

        .analise-title {
            font-size: 12px;
            color: var(--muted);
            margin-top: 4px;
        }
        .analise-value {
            font-size: 24px;
            font-weight: 900;
            margin: 4px 0;
            text-align: center;
        }
        .neon-blue .analise-value { color: var(--blue-neon); }
        .neon-purple .analise-value { color: var(--purple-neon); }
        .neon-pink .analise-value { color: var(--pink-neon); }
        
        /* HISTÓRICO DE VELAS (AJUSTADO) */
        .payouts-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr); 
            gap: 8px;
            overflow: hidden; 
        }
        .payout-item {
            display: flex; 
            flex-direction: column;
            justify-content: center;
            align-items: center; /* Centralizado */
            padding: 6px 0; 
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.15s ease;
        }

        .payout-mult {
            font-weight: 700;
            font-size: 0.95rem; 
            line-height: 1.2;
            text-align: center;
        }
        
        /* Cores Neon nos Multiplicadores do Histórico */
        .payout-blue .payout-mult { color: var(--blue-neon); }
        .payout-purple .payout-mult { color: var(--purple-neon); }
        .payout-pink .payout-mult { color: var(--pink-neon); }
        
        /* Horário (Menor e Branco) */
        .payout-time {
            font-size: 0.65rem; 
            font-weight: 500;
            color: var(--text); /* Cor branca */
            line-height: 1;
            margin-top: 4px; /* Ajustado para melhor espaçamento */
            white-space: nowrap; /* Não quebrar o ícone e o horário */
        }
        
        /* Cores do Histórico de Fundo (Mantido) */
        .payout-blue { background-color: var(--hist-blue-bg); border-color: rgba(37, 99, 235, 0.5); }
        .payout-purple { background-color: var(--hist-purple-bg); border-color: rgba(124, 58, 237, 0.6); }
        .payout-pink { background-color: var(--hist-pink-bg); border-color: rgba(236, 72, 153, 0.7); }

        /* Estilos ajustados para o log feed (Mantido) */
        #feed { 
            max-height: 200px; 
            overflow-y: hidden; 
            padding: 0; 
            margin: 0;
            display: flex;
            flex-direction: column-reverse; 
        }
        #feed .item { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: 6px 0; 
            border-top: 1px solid var(--stroke); 
            font-size: 0.85rem; 
            color: var(--text); 
        }
        #feed .chip { 
            padding: 2px 6px; 
            border-radius: 4px; 
            font-weight: 600; 
            font-size: 0.7rem; 
            min-width: 45px;
            text-align: center;
        }
        #feed .chip.ok { background: rgba(34, 197, 94, 0.2); color: var(--success); } 
        #feed .chip.err { background: rgba(239, 68, 68, 0.2); color: var(--danger); } 
        #feed .chip.warn { background: rgba(37, 99, 235, 0.2); color: var(--blue-neon); } 
    </style>
</head>
<body>
    <div id="mainContent" class="p-3">
        <div class="container-fluid">
            
            <div class="d-flex justify-content-between align-items-center mb-4">
                <div class="btn-group">  
                    <button class="btn btn-simple-icon" id="serverStatusBtn" title="Status do Servidor" style="font-size: 0.8rem;">
                        <span id="liveStatus" class="d-flex align-items-center text-success" title="Servidor">
                            <i style="font-style: normal;">●</i> Conectando...
                        </span>
                    </button>
                    <a class="btn btn-simple-icon" href="selecao.html" title="Voltar para Dashboard">
                        <i style="font-style: normal;">⌂</i>
                    </a>
                </div>
            
                <a href="#" class="d-flex justify-content-center align-items-center">
                    <img src="https://i.postimg.cc/vmrLNvv6/logo1.png" alt="Logo" style="height: 75px;">
                </a>
            
                <div class="btn-group">
                    <a href="#" class="btn btn-simple-icon" title="Histórico de Sinais">
                        <i style="font-style: normal;">◷</i>
                    </a>
                    <button class="btn btn-simple-icon" title="Ajustes">
                        <i style="font-style: normal;">⚙</i>
                    </button>
                </div>
            </div>
            <section class="mb-4">
                <div class="chance-card chance-awaiting" id="chanceCard">
                    <div id="topslide" class="topslide"></div>
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <div class="chance-title" id="chanceTitle">Chance de 2x</div>
                            <div class="chance-sub" id="chanceSub">Aguardando padrão</div>
                        </div>
                    </div>
                    <div class="sep"></div>
                    <div class="d-flex flex-wrap gap-2">
                        <div class="pill" id="strategyTag">Estratégia: —</div>
                        <div class="pill" id="gateTag">Gatilho: —</div>
                        <div class="pill" id="martingaleTag" style="display:none;">G1/G2 ativo</div>
                    </div>
                </div>
            </section>
            <h5 class="text-white fw-bold mb-3 d-flex align-items-center" style="font-size: 1rem;">
                <span style="font-size: 1.1em; color: var(--purple-neon); margin-right: 5px;">&#9654;</span> 
                Próxima vela com base em Análise
            </h5>
            <div class="output-cards-container mb-4">
                <div class="analise-card neon-blue" id="card-media-conservadora">
                    <div class="analise-title">Garantia</div>
                    <div class="analise-value" id="mediaConservadoraValue">1.54x</div>
                </div>
                <div class="analise-card neon-purple" id="card-media-mediana">
                    <div class="analise-title">Mediana</div>
                    <div class="analise-value" id="mediaMedianaValue">4.50x</div>
                </div>
                <div class="analise-card neon-pink" id="card-alto-risco">
                    <div class="analise-title">Alto Risco</div>
                    <div class="analise-value" id="altoRiscoValue">12.55x</div>
                </div>
            </div>
            <section class="card mb-4 p-3">
                <h5 class="text-white fw-bold mb-3" style="font-size: 1rem;">Log de Atividades</h5>
                <div id="feed">
                    </div>
            </section>

            <h5 class="text-white fw-bold mb-3 d-flex align-items-center" style="font-size: 1rem;">
                <span style="font-size: 1.1em; color: var(--purple-neon); margin-right: 5px;">&#x23F1;</span>
                Últimas 24 Velas
            </h5>
            <div class="payouts-container mb-4" id="history">
                </div>

        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <script>
// ======================================================================================================
// Conteúdo do 'botscript.js' adaptado ao novo layout (V10 - Cálculo Reativo Ajustado)
// ======================================================================================================

// Config Firebase (AGORA COM A CHAVE DO 'dashaposta1.html')
const firebaseConfig = {
  apiKey: "AIzaSyDEzE-QxM8X0zB0VlB-c4W_aF9Z_uO_1C0",
  authDomain: "aviatormax-ac28e.firebaseapp.com",
  databaseURL: "https://aviatormax-ac28e-default-rtdb.firebaseio.com",
  projectId: "aviatormax-ac28e",
  storageBucket: "aviatormax-ac28e.firebasestorage.app",
  messagingSenderId: "803925677451",
  appId: "1:803925677451:web:92a8e97799adcf63ea0b8e",
  measurementId: "G-91BL357JVK"
};

// ===================== UI Helpers ================================
const $ = s => document.querySelector(s);
const liveStatus = $("#liveStatus");
const engineStatus = { textContent: "Iniciando..." }; 
const predStatus = { textContent: "" }; 
const blueRunPill = { textContent: "Azuis seguidas: 0" }; 
const chanceCard = $("#chanceCard");
const chanceTitle = $("#chanceTitle");
const chanceSub = $("#chanceSub");
const strategyTag = $("#strategyTag");
const gateTag = $("#gateTag");
const martingaleTag = $("#martingaleTag");
const feed = $("#feed");
const historyGrid = $("#history");
const topslide = $("#topslide");

function flashCard(){
  chanceCard.classList.add("chance-animate");
  setTimeout(()=> chanceCard.classList.remove("chance-animate"), 260);
}

function setCardState({active=false, awaiting=false, title="Chance de 2x", sub="identificando padrão"}){
  chanceTitle.textContent = title;
  chanceSub.textContent = sub;
  chanceCard.classList.remove("chance-active","chance-awaiting", "chance-blocked");
  if(active) { chanceCard.classList.add("chance-active"); flashCard(); }
  else if(awaiting) chanceCard.classList.add("chance-awaiting");
  else if(title === "SINAL BLOQUEADO") chanceCard.classList.add("chance-blocked");
}

function topSlide(msg, ok=true){
  topslide.textContent = msg;
  topslide.className = "topslide " + (ok?"ok":"err");
  topslide.classList.add("show");
  setTimeout(()=> topslide.classList.remove("show"), 1000);
}

function addFeed(type,text){
  const div = document.createElement("div"); div.className="item";
  const left=document.createElement("div"); left.textContent=text;
  const right=document.createElement("div"); 
  
  let chipClass;
  if (type === "ok") { chipClass = "ok"; right.textContent = "WIN"; }
  else if (type === "err") { chipClass = "err"; right.textContent = "LOSS"; }
  else { chipClass = "warn"; right.textContent = "INFO"; } 
  
  right.className = "chip " + chipClass;
  div.appendChild(left); div.appendChild(right); 
  feed.prepend(div);

  while(feed.children.length > 7){
    feed.removeChild(feed.lastChild);
  }
}

// RENDERIZAÇÃO DO HISTÓRICO (AJUSTADO PARA ICONE ⏱ e COR BRANCA)
function renderHistory(list){
  const historyGrid = document.getElementById("history");
  historyGrid.innerHTML = "";
  const last24 = list.slice(-24).reverse();
  last24.forEach(r => {
    const box = document.createElement("div"); 
    box.className = "payout-item payout-" + r.color; 
    
    // Multiplicador (em cima)
    const multDiv = document.createElement("div");
    multDiv.className = "payout-mult";
    multDiv.textContent = r.mult.toFixed(2) + "x";
    box.appendChild(multDiv);
    
    // Horário (em baixo com ícone)
    if (r.ts) {
        const time = new Date(r.ts);
        const timeString = time.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
        const timeDiv = document.createElement("div");
        timeDiv.className = "payout-time";
        // Adicionando o ícone ⏱
        timeDiv.innerHTML = `⏱ ${timeString}`; 
        box.appendChild(timeDiv);
    }
    
    historyGrid.appendChild(box);
  });
}

// ===================== Persistência ======================
const store = {
  get(){ try{ return JSON.parse(localStorage.getItem("stats2x")||"{}"); }catch{return {}} },
  set(d){ localStorage.setItem("stats2x", JSON.stringify(d)); }
};
let stats = Object.assign({wins:0,losses:0,streak:0,maxStreak:0,normalWins:0,g1Wins:0,g2Wins:0}, store.get());

// ===================== Utils =======================
function colorFrom(mult){ if(mult<2.0) return "blue"; if(mult<10.0) return "purple"; return "pink"; }
const isPos = (c) => c==="purple" || c==="pink";

// ===== JANELAS PERSONALIZADAS E FUNÇÕES DE ANÁLISE (Mantidas) =====
const WINDOW_PRED = 6;
const WINDOW_CORR = 7;

function getLastNColors(arr, n){ return arr.slice(-n).map(r=>r.color); }

function predominancePct(colorsLastN){
  const pos = colorsLastN.filter(c => c==="purple" || c==="pink").length;
  return colorsLastN.length ? pos/colorsLastN.length : 0;
}

function getMaxBlueStreakN(colorsLastN){
  let max = 0, run = 0;
  for(const c of colorsLastN){
    if(c==="blue"){ run++; if(run>max) max=run; }
    else run = 0;
  }
  return max;
}

function lastKBlueStreakRecency(colorsLastN, k=3){
  let run=0;
  for(let i=colorsLastN.length-1;i>=0;i--){
    if(colorsLastN[i]==="blue"){ run++; if(run>=k) return colorsLastN.length-1-i; }
    else run=0;
  }
  return Infinity;
}

function twoPosNow(colors){
  const L = colors.length;
  return L>=2 && (colors[L-1]!=="blue") && (colors[L-2]!=="blue");
}

function finalBlueRunNow(colors){
  let r=0; for(let i=colors.length-1;i>=0 && colors[i]==="blue"; i--) r++; return r;
}

function consecutiveBlueCount(list){
  let c=0; for(let i=list.length-1;i>=0;i--){ if(list[i].color==="blue") c++; else break; } return c;
}

function isXadrezBPB(colors){
  const L = colors.length;
  return L >= 3 && colors[L[L-3]] === "blue" && isPos(colors[L-2]) && colors[L-1] === "blue";
}

// ===================== Parâmetros =======================
const SOFT_PCT = 0.50; 
const STRONG_PCT = 0.60; 

// Variáveis de estado
window.seguidinhaOn = false; 
window.prevCorrGate = null;
let maxBlueStreakHistory = []; 
let waitingForNewCorrections = 0;

// ===================== Estratégias (Mantidas) =======================
function detectStrategies(colors, predNPct){
  const L=colors.length; if(L<3) return null;
  const a=colors[L-3], b=colors[L-2], c=colors[L-1];
  const isPos = x => x!=="blue";

  if(isPos(a) && isPos(b) && isPos(c)){
    let run=0; for(let i=L-1;i>=0 && isPos(colors[i]); i--) run++;
    if(run>=4) return {name:`surfing-4+`, gate:`${run} positivas ⇒ P (2x)`};
    if(run===3) return {name:`sequência roxas 3`, gate:`3 positivas ⇒ P (2x)`};
  }

  if(isXadrezBPB(colors)) return {name:"xadrez B-P-B", gate:"B-P-B ⇒ P (2x)"};

  if(predNPct>=0.60 && c==="blue"){
    return {name:"predominancia-forte", gate:`Pred ${(predNPct*100).toFixed(0)}% + Azul ⇒ P (2x)`};
  }

  return null;
}

function ngramPositiveProb(colors, order, windowSize=120){ 
  if(colors.length <= order) return null;
  const POS = new Set(["purple","pink"]);
  const window = colors.slice(-windowSize);
  const counts = new Map();
  for(let i=order;i<window.length;i++){
    const ctx = window.slice(i-order, i).join("|");
    const next = window[i];
    const obj = counts.get(ctx) || {total:0, pos:0};
    obj.total += 1; if(POS.has(next)) obj.pos += 1; counts.set(ctx, obj);
  }
  const ctxNow = colors.slice(-order).join("|");
  const stat = counts.get(ctxNow);
  if(!stat) return null;
  return {p: stat.pos/stat.total, n: stat.total};
}

function detectRepetitionStrategy(colors){ 
  for(const k of [4,3,2]){
    const res = ngramPositiveProb(colors, k, 12); 
    if(res && res.n >= 1 && res.p >= 0.70){ 
      return {name:`rep_cores k=${k} (W12)`, gate:`Repetição (12 velas): P(pos|ctx)=${(res.p*100).toFixed(0)}% · n=${res.n}`}; 
    }
  }
  for(const k of [3,2]){
    const res = ngramPositiveProb(colors, k, 8);
    if(res && res.n >= 1 && res.p >= 0.90){ 
      return {name:`rep_cores k=${k} (W8)`, gate:`Repetição (8 velas): P(pos|ctx)=${(res.p*100).toFixed(0)}% · n=${res.n}`}; 
    }
  }
  return null;
}

function modelSuggest(colors){ 
  for(const k of [4,3,2]){
    const res = ngramPositiveProb(colors, k, 120); 
    if(res && res.n>=2 && res.p>=0.40){ 
      return {name:`modelo n-grama k=${k}`, gate:`IA: P(positiva|ctx)=${(res.p*100).toFixed(0)}% · n=${res.n}`}; 
    }
  }
  return null;
}

function getStrategyAndGate(colors, arr40, arr, predNPct, allowMacro = true){
  let suggestion = detectStrategies(colors, predNPct) || 
                   detectRepetitionStrategy(colors) || 
                   modelSuggest(colors); 
  
  const isStrongStrategy = !!suggestion; 

  if(isStrongStrategy || (allowMacro && predNPct >= SOFT_PCT)){
    const usedName = isStrongStrategy ? suggestion.name : "macro";
    const usedGate = isStrongStrategy ? suggestion.gate : "tempo/rosa/surf/coluna (40m)";
    return { name: usedName, gate: usedGate, suggestion, isStrongStrategy };
  }
  return null;
}

function isXadrezAlternado4(colors){
  if(colors.length < 4) return false;
  const a = colors[colors.length-4];
  const b = colors[colors.length-3];
  const c = colors[colors.length-2];
  const d = colors[colors.length-1];

  return (a !== b) && (b !== c) && (c !== d);
}

// ===================== LÓGICA DE PREVISÃO DE MULTIPLICADORES (AJUSTADA) ======================
function calculateTargets(arr){
  // Usar os 120 últimos registros (objetos completos)
  const history = arr.slice(-120); 

  // 1. Garantia (Azuis: 1.00x a 1.99x)
  const blueMults = history.filter(r => r.color === 'blue').map(r => r.mult);
  // Média dos últimos 5 azuis (Ajustado de 10 para 5)
  const last5Blue = blueMults.slice(-5);
  const garantiaAvg = last5Blue.length > 0 
    ? (last5Blue.reduce((a, b) => a + b, 0) / last5Blue.length)
    : 1.54; 

  // 2. Mediana (Roxas: 2.00x a 9.99x)
  const purpleMults = history.filter(r => r.color === 'purple').map(r => r.mult);
  // Média dos últimos 5 roxos (Ajustado de 10 para 5)
  const last5Purple = purpleMults.slice(-5);
  const medianaAvg = last5Purple.length > 0
    ? (last5Purple.reduce((a, b) => a + b, 0) / last5Purple.length)
    : 4.50; 

  // 3. Alto Risco (Rosas: 10.00x+ com teto de 200.99x)
  const pinkMultsRaw = history.filter(r => r.color === 'pink').map(r => r.mult);
  // Limita os multiplicadores a 200.99x antes de calcular a média
  const pinkMultsCapped = pinkMultsRaw.map(m => Math.min(m, 200.99));
  // Média dos últimos 5 rosas (capados) (Mantido em 5)
  const last5PinkCapped = pinkMultsCapped.slice(-5);

  const altoRiscoAvg = last5PinkCapped.length > 0
    ? (last5PinkCapped.reduce((a, b) => a + b, 0) / last5PinkCapped.length)
    : 12.55; 
    
  // Aplicando limites razoáveis de saída
  let targetGarantia = Math.min(Math.max(garantiaAvg, 1.18), 1.90);
  let targetMediana = Math.min(Math.max(medianaAvg, 2.15), 9.99);
  let targetAltoRisco = Math.min(Math.max(altoRiscoAvg, 10.55), 200.00);

  return {
      garantia: parseFloat(targetGarantia.toFixed(2)),
      mediana: parseFloat(targetMediana.toFixed(2)),
      altoRisco: parseFloat(targetAltoRisco.toFixed(2))
  };
}
// ========================================================================================


// ===================== Motor (Mantido) ======================
let pending = null;
let currentCycleLoss = false;
let lastG0Strategy = null;
let pendingIsIsolated = false; 

function clearPending(){ 
  pending = null; 
  martingaleTag.style.display = "none"; 
  setCardState({active:false, awaiting:false}); 
}

function onNewCandle(arr){
  if(arr.length < Math.min(WINDOW_PRED, WINDOW_CORR)) return;
  renderHistory(arr);

  const colors = arr.map(r=>r.color);
  const last = arr[arr.length-1];
  const lastMultTxt = last.mult.toFixed(2)+"x";

  // ===== ATUALIZAÇÃO DOS CARDS DE PREVISÃO =====
  const targets = calculateTargets(arr);
  $("#mediaConservadoraValue").textContent = targets.garantia.toFixed(2) + "x";
  $("#mediaMedianaValue").textContent = targets.mediana.toFixed(2) + "x";
  $("#altoRiscoValue").textContent = targets.altoRisco.toFixed(2) + "x";
  // =============================================

  // ===== JANELAS =====
  const colorsPred = getLastNColors(arr, WINDOW_PRED);
  const predN = predominancePct(colorsPred);

  // Calcular probabilidade Azul para o subtítulo
  const chances = (function(history) {
        if (history.length === 0) return { blue: 0, purple: 0, pink: 0 };
        const blueCount = history.filter(c => c === "blue").length;
        return { blue: (blueCount / history.length) * 100 };
    })(colors);
    
    // Atualiza subtítulo do card de chance com a % de Azuis
    const defaultSub = `Aguardando padrão (Azul: ${chances.blue.toFixed(1)}%)`;
  
  // ===== Lógica de Estratégia e Correção (Mantida) =====
  const colorsCorr = getLastNColors(arr, WINDOW_CORR);
  const corrN = getMaxBlueStreakN(colorsCorr);
  const recTripla = lastKBlueStreakRecency(colorsCorr, 3);
  const twoPos = twoPosNow(colors);
  let corrGate = corrN;
  if(corrN===3 && recTripla>=5 && (twoPos || predN>=0.60) && finalBlueRunNow(colors)<=1) corrGate = 2;
  const analysis = getStrategyAndGate(colors, [], arr, predN, false);
  const strongStrategyActive = !!analysis;
  
  // ===== RASTREIA MUDANÇAS DE CORREÇÃO (Mantido) =====
  const prevCorr = window.prevCorrGate;
  if(prevCorr !== undefined && corrGate !== prevCorr){
    maxBlueStreakHistory.push({idx: last.idx, streak: corrGate});
    if(maxBlueStreakHistory.length > 20) maxBlueStreakHistory.shift();
  }
  window.prevCorrGate = corrGate;

  const currentBlueRun = finalBlueRunNow(colors);

  // ===== FINALIZAÇÃO DE ENTRADA (Mantida) =====
  if(pending && pending.enterAtIdx === last.idx){
    const win = last.mult >= 2.0;
    if(win){
      currentCycleLoss = false;
      stats.wins++; stats.streak++; stats.maxStreak = Math.max(stats.maxStreak, stats.streak);
      if(pending.stage===0) stats.normalWins++;
      else if(pending.stage===1) stats.g1Wins++;
      else stats.g2Wins++;
      store.set(stats);
      addFeed("ok", `WIN 2x (G${pending.stage})`);
      clearPending();
      lastG0Strategy = null;
    } else {
      if(pending.stage === 0){
        addFeed("err", "LOSS 2x (G0)"); 
        currentCycleLoss = true; lastG0Strategy = pending.strategy;
        pending.stage = 'G1_WAIT'; pending.enterAtIdx = null;
        setCardState({active:false, awaiting:true, title:"Chance de 2x G1", sub:defaultSub});
        addFeed("warn", "Aguardando novo gatilho para G1");
      }
      if(pending.stage === 1){
        addFeed("err", "LOSS 2x (G1)"); 
        pending.stage = 'G2_WAIT'; pending.enterAtIdx = null;
        setCardState({active:false, awaiting:true, title:"Chance de 2x G2", sub:defaultSub});
        addFeed("warn", "Aguardando novo gatilho para G2");
      }
      if(pending.stage === 2){
        addFeed("err", "LOSS 2x (G2)"); 
        stats.losses++;
        stats.streak = 0;
        store.set(stats);
        clearPending(); lastG0Strategy = null;
        currentCycleLoss = false;
      }
    }
  }

  // ===== SEGUIDINHA (Mantido) =====
  const minSeg = 4;
  const lastN = colors.slice(-Math.max(minSeg, colors.length));
  const blueInLastN = lastN.filter(c => c === "blue").length;
  const isSeguidinha = lastN.length >= minSeg && blueInLastN <= 1;

  if (isSeguidinha && !window.seguidinhaOn) {
    window.seguidinhaOn = true;
    addFeed("warn", `SEGUIDINHA ON: ${lastN.length} velas, ${blueInLastN} azul`);
  }
  if (!isSeguidinha && window.seguidinhaOn && lastN.length >= 6) {
    window.seguidinhaOn = false;
    addFeed("warn", "SEGUIDINHA OFF: padrão quebrado");
  }

  // ===== PROCESSAR WAITS (G1_WAIT, G2_WAIT) - Lógica de Bloqueio mantida =====
  if(pending?.stage === 'G1_WAIT'){
    
    // if cycle nasceu isolado -> não faz G1
if(pendingIsIsolated){
    setCardState({active:false, awaiting:true, title:`Aguardando G1`, sub:`Cycle isolado (2B atrás) — aguardando ponto seguro`});
    addFeed("warn","G1 pausado — cycle nasceu isolado");
    return;
}

    // BLOQUEIO G1 se tiver 2 blues antes
{
  const last2 = colors.slice(-2);
  if(last2[0] === "blue" && last2[1] === "blue"){
    setCardState({active:false, awaiting:true, title:"Aguardando G1", sub:"2 blues antes — aguardando próximo padrão seguro"});
    addFeed("warn","G1 pausado — 2 Blue antes. Mantendo cycle.");
    return;
  }
}

  // FILTRO INTELIGENTE DE CONTEXTO G1
{
  const L = colors.length;
  if(L >= 6){

    const c = colors;
    const isPos = (v)=>v !== "blue";
    const isBlue = (v)=>v === "blue";

    // força de 2 positivas consecutivas dentro das últimas 6 velas
    let force = false;
    for(let i=L-6;i<L-1;i++){
       if(isPos(c[i]) && isPos(c[i+1])){ force=true; break; }
    }

    // padrões xadrez
    const BPBP = isBlue(c[L-4]) && isPos(c[L-3]) && isBlue(c[L-2]) && isPos(c[L-1]);
    const PBPB = isPos(c[L-4]) && isBlue(c[L-3]) && isPos(c[L-2]) && isBlue(c[L-1]);

    // BBPP (sem chance para Blue)
    const BBPP = isBlue(c[L-4]) && isBlue(c[L-3]) && isPos(c[L-2]) && isPos(c[L-1]);

    // BBPPP (espera confirmação extra ainda)
    const BBPPP = isBlue(c[L-5]) && isBlue(c[L-4]) && isPos(c[L-3]) && isPos(c[L-2]) && isPos(c[L-1]);

    if(force){
        setCardState({active:false, awaiting:true, title:`Aguardando G1`, sub:`Aguardando G1 — força detectada`});
        addFeed("warn", "Aguardando G1 — força detectada");
        return;
    }

    if(!force && (BPBP || PBPB)){
        // deixa seguir xadrez normal
    } else if(BBPP && isBlue(c[L-1])){
        setCardState({active:false, awaiting:true, title:`Aguardando G1`, sub:`BBPP — sem Blue agora`});
        addFeed("warn", "G1 pausado — BBPP sem Blue");
        return;
    } else if(BBPPP){
        setCardState({active:false, awaiting:true, title:`Aguardando G1`, sub:`BBPPP — aguardar próxima P`});
        addFeed("warn", "G1 pausado — BBPPP aguardando próxima positiva");
        return;
    }
  }
}
    
    // XADREZ — G1 só entra após confirmar 1 azul
if(isXadrezAlternado4(colors)){
   if(colors[colors.length-1] === "blue"){
      // azul confirmada → libera G1 normal (faz nada, só continua)
   } else {
      setCardState({active:false, awaiting:true, title:"Aguardando G1", sub:"Xadrez detectado — aguardando azul"});
      addFeed("warn","G1 pausado (xadrez) — Aguardando possivel xadrez");
      return;
   }
}

    if(!strongStrategyActive && !window.seguidinhaOn){
      setCardState({active:false, awaiting:true, title:"Aguardando G1", sub:defaultSub});
      return; 
    }
    if(analysis && analysis.name === lastG0Strategy){
      setCardState({active:false, awaiting:true, title:"Aguardando G1", sub:"Mesma estratégia do G0"});
      return;
    }
    pending.stage = 1; pending.enterAtIdx = last.idx + 1; pending.strategy = analysis?.name || "seguidinha"; pending.afterMult = lastMultTxt;
    martingaleTag.style.display = "inline-block";
    setCardState({active:true, title:"Chance de 2x G1", sub:`entrar após (${pending.afterMult})`});
    strategyTag.textContent = "Estratégia: " + pending.strategy;
    gateTag.textContent = "Gatilho: " + (analysis?.gate || "seguidinha");
    addFeed("warn", `SINAL 2x (G1) — entrar após (${pending.afterMult})`);
    return;
  }

  if(pending?.stage === 'G2_WAIT'){
    // if cycle nasceu isolado -> não faz G2
    if(pendingIsIsolated){
    setCardState({active:false, awaiting:true, title:`Aguardando G2`, sub:`Cycle isolado (2B atrás) — aguardando ponto seguro`});
    addFeed("warn","G2 pausado — cycle isolado");
    return;
}
    
    // BLOQUEIO G2 se tiver 2 blues antes
{
  const last2 = colors.slice(-2);
  if(last2[0] === "blue" && last2[1] === "blue"){
    setCardState({active:false, awaiting:true, title:"Aguardando G2", sub:"2 blues antes — aguardando próximo padrão seguro"});
    addFeed("warn","G2 pausado — 2 Blue antes. Mantendo cycle.");
    return;
  }
}

    // FILTRO INTELIGENTE DE CONTEXTO G2
{
  const L = colors.length;
  if(L >= 6){

    const c = colors;
    const isPos = (v)=>v !== "blue";
    const isBlue = (v)=>v === "blue";

    // força de 2 positivas consecutivas dentro das últimas 6 velas
    let force = false;
    for(let i=L-6;i<L-1;i++){
       if(isPos(c[i]) && isPos(c[i+1])){ force=true; break; }
    }

    // padrões xadrez
    const BPBP = isBlue(c[L-4]) && isPos(c[L-3]) && isBlue(c[L-2]) && isPos(c[L-1]);
    const PBPB = isPos(c[L-4]) && isBlue(c[L-3]) && isPos(c[L-2]) && isBlue(c[L-1]);

    // BBPP (sem chance para Blue)
    const BBPP = isBlue(c[L-4]) && isBlue(c[L-3]) && isPos(c[L-2]) && isPos(c[L-1]);

    // BBPPP (espera confirmação extra ainda)
    const BBPPP = isBlue(c[L-5]) && isBlue(c[L-4]) && isPos(c[L-3]) && isPos(c[L-2]) && isPos(c[L-1]);

    if(force){
        setCardState({active:false, awaiting:true, title:`Aguardando G2`, sub:`Aguardando G2 — força detectada`});
        addFeed("warn", "Aguardando G2 — força detectada");
        return;
    }

    if(!force && (BPBP || PBPB)){
        // deixa seguir xadrez normal
    } else if(BBPP && isBlue(c[L-1])){
        setCardState({active:false, awaiting:true, title:`Aguardando G2`, sub:`BBPP — sem Blue agora`});
        addFeed("warn", "G2 pausado — BBPP sem Blue");
        return;
    } else if(BBPPP){
        setCardState({active:false, awaiting:true, title:`Aguardando G2`, sub:`BBPPP — aguardar próxima P`});
        addFeed("warn", "G2 pausado — BBPPP aguardando próxima positiva");
        return;
    }
  }
}
    
    // XADREZ — G2 só entra após confirmar 1 azul
if(isXadrezAlternado4(colors)){
   if(colors[colors.length-1] === "blue"){
      // azul confirmada → libera G2 normal
   } else {
      setCardState({active:false, awaiting:true, title:"Aguardando G2", sub:"Xadrez detectado — aguardando azul"});
      addFeed("warn","G2 pausado (xadrez) — Aguardando possivel xadrez");
      return;
   }
}

    if(!strongStrategyActive && !window.seguidinhaOn){
      setCardState({active:false, awaiting:true, title:"Aguardando G2", sub:defaultSub});
      return;
    }
    if(analysis && (analysis.name === lastG0Strategy || analysis.name === pending.strategy)){
      setCardState({active:false, awaiting:true, title:"Aguardando G2", sub:"Mesma estratégia anterior"});
      return;
    }
    pending.stage = 2; pending.enterAtIdx = last.idx + 1; pending.strategy = analysis.name; pending.afterMult = lastMultTxt;
    martingaleTag.style.display = "inline-block";
    setCardState({active:true, title:"Chance de 2x G2", sub:`entrar após (${pending.afterMult})`});
    strategyTag.textContent = "Estratégia: " + pending.strategy;
    gateTag.textContent = "Gatilho: " + analysis.gate;
    addFeed("warn", `SINAL 2x (G2) — entrar após (${pending.afterMult})`);
    return;
  }

  // ===== BLOQUEIO: 3+ AZUIS SEGUIDOS - só para novos G0, não retorna se pending (Mantido) =====
  if (currentBlueRun >= 3) {
    if (waitingForNewCorrections === 0) {
      waitingForNewCorrections = 1;
      setCardState({active:false, awaiting:true, title:"SINAL BLOQUEADO", sub:"3+ azuis seguidos → aguardando 1 nova"});
      addFeed("warn", "Bloqueio: 3+ azuis. Aguardando 1 nova correção ≤2.");
      engineStatus.textContent = "bloqueado (3+ azuis)";
    }
    if (pending) {
      // Se pending existe (cycle em andamento), continuar normalmente (já processado acima)
    } else {
      return; // Só return se não pending, para bloquear novos G0
    }
  }

  // ===== DESBLOQUEIO: 1 nova correção ≤2 (Mantido) =====
  if (waitingForNewCorrections > 0) {
    const lastChange = maxBlueStreakHistory[maxBlueStreakHistory.length - 1];
    if (lastChange && lastChange.streak <= 2) {
      waitingForNewCorrections = 0;
      addFeed("warn", "Desbloqueado: nova correção ≤2 confirmada.");
      engineStatus.textContent = "operando";
      setCardState({active:false, awaiting:false, title:"Chance de 2x", sub:defaultSub});
      // Não clearPending, preserva cycle
    } else {
      setCardState({active:false, awaiting:true, title:"SINAL BLOQUEADO", sub:"Aguardando 1 nova correção ≤2"});
      if (pending) {
        // Permitir processar WAIT (já feito acima)
      } else {
        return; // Bloquear novos se não pending
      }
    }
  }

  // ===== NOVO SINAL G0 - só se não bloqueado e !pending (Mantido) =====
  if (!pending && waitingForNewCorrections === 0) {
    if (window.seguidinhaOn) {
      pending = { stage: 0, enterAtIdx: last.idx + 1, strategy: "seguidinha", afterMult: lastMultTxt };
      setCardState({active:true, title:"Chance de 2x", sub:`entrar após (${pending.afterMult})`});
      strategyTag.textContent = "Estratégia: seguidinha";
      gateTag.textContent = "Gatilho: sequência positiva (0-1 azul)";
      addFeed("warn", `SINAL 2x (G0) — SEGUIDINHA ON`);
      return;
    }

    const allowEntry = corrGate <= 2 || (corrGate === 3 && predN >= 0.65 && strongStrategyActive);
    if (allowEntry) {
      pending = { stage: 0, enterAtIdx: last.idx + 1, strategy: analysis?.name || "correção", afterMult: lastMultTxt };
          // se nasceu isolada com 2 blues atrás -> cycle isolado
     const P  = (colors[colors.length-1] !== "blue");
     const B1 = (colors[colors.length-2] === "blue");
     const B2 = (colors[colors.length-3] === "blue");
      
      pendingIsIsolated = (P && B1 && B2);

      setCardState({active:true, title:"Chance de 2x", sub:`entrar após (${pending.afterMult})`});
      strategyTag.textContent = "Estratégia: " + pending.strategy;
      gateTag.textContent = "Gatilho: " + (analysis?.gate || "correção ≤2");
      addFeed("warn", `SINAL 2x (G0) — entrar após (${pending.afterMult})`);
    } else {
      setCardState({active:false, awaiting:true, title:"Chance de 2x", sub:"Aguardando padrão"});
      strategyTag.textContent = "Estratégia: —";
      gateTag.textContent = "Gatilho: —";
    }
  }

  engineStatus.textContent = window.seguidinhaOn ? "SEGUIDINHA ON" : (waitingForNewCorrections > 0 ? "bloqueado (3+ azuis)" : "operando");
}

// ===================== Firebase (Mantido) =======================
function toArrayFromHistory(raw){
  const rows = [];
  const vals = Object.values(raw || {});
  for(let i=0;i<vals.length;i++){
    const it = vals[i];
    const mult = parseFloat(it?.value);
    if(!Number.isFinite(mult)) continue;
    const color = (it?.color==="blue"||it?.color==="purple"||it?.color==="pink") ? it.color : colorFrom(mult);
    let ts=null;
    if(it?.date && it?.time){
      const d = new Date(`${it.date}T${it.time}`);
      if(Number.isFinite(d.getTime())) ts=d.getTime();
    }
    rows.push({ idx:i, mult, color, ts });
  }
  return rows;
}

(function init(){
  try{
    const app = firebase.initializeApp(firebaseConfig);
    liveStatus.innerHTML = '<i style="font-style: normal;">●</i> Conectado';
    liveStatus.style.color="var(--success)";
    const dbRef = app.database().ref("history/");
    dbRef.on('value',(snapshot)=>{
      const data = snapshot.val();
      const arr = toArrayFromHistory(data);
      if(!arr.length){ engineStatus.textContent="sem dados"; return; }
      onNewCandle(arr);
    },(error)=>{
      liveStatus.innerHTML = '<i style="font-style: normal;">●</i> Erro';
      liveStatus.style.color="var(--danger)";
      setTimeout(init, 5000); // Reconectar
    });

    // Reset periódico
    setInterval(() => {
      if (waitingForNewCorrections > 0 || !pending && engineStatus.textContent.includes("bloqueado")) {
        waitingForNewCorrections = 0;
        clearPending();
        window.seguidinhaOn = false;
        maxBlueStreakHistory = [];
        window.prevCorrGate = null;
        addFeed("warn", "Reset automático após inatividade.");
        engineStatus.textContent = "operando";
      }
    }, 1800000); // 30 min
  }catch(e){
    liveStatus.innerHTML = '<i style="font-style: normal;">●</i> Falha ao iniciar';
    liveStatus.style.color="var(--danger)";
    console.error(e);
  }
})();

// ===================== BLOQUEIO DEVTOOLS (Mantido) =======================
(function() {
  const threshold = 160; 
  let devtoolsOpen = false;
  const checkDevTools = () => {
    const width = window.innerWidth;
    const height = window.innerHeight;
    if (width < threshold || height < threshold) {
      if (!devtoolsOpen) { devtoolsOpen = true; window.location.replace("https://www.google.com"); }
    } else { devtoolsOpen = false; }
  };
  window.addEventListener('resize', checkDevTools);
  checkDevTools();
  document.addEventListener('keydown', function (e) {
    if (e.key === 'F12' || e.keyCode === 123) e.preventDefault();
    if (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'i')) e.preventDefault();
    if (e.ctrlKey && e.shiftKey && (e.key === 'J' || e.key === 'j')) e.preventDefault();
  });
  document.addEventListener('contextmenu', function (e) { e.preventDefault(); });
})();
    </script>
</body>
</html>